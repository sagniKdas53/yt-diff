"use strict";
const { Sequelize, DataTypes } = require("sequelize");
const fs = require("fs");
const path = require("path");

// Configuration object (simplified for this script)
const config = {
  db: {
    host: process.env.DB_HOST || "localhost",
    user: process.env.DB_USERNAME || "ytdiff",
    name: "vidlist",
    password: process.env.DB_PASSWORD_FILE
      ? fs.readFileSync(process.env.DB_PASSWORD_FILE, "utf8").trim()
      : process.env.DB_PASSWORD && process.env.DB_PASSWORD.trim()
        ? process.env.DB_PASSWORD
        : new Error("DB_PASSWORD or DB_PASSWORD_FILE environment variable must be set"),
  },
  saveLocation: process.env.SAVE_PATH || "/home/sagnik/Videos/yt-dlp/",
  restrictFilenames: process.env.RESTRICT_FILENAMES !== "false",
};

// Logging (simplified)
const logger = {
  info: (message, fields = {}) => console.log(JSON.stringify({ level: 'info', message, ...fields })),
  error: (message, fields = {}) => console.error(JSON.stringify({ level: 'error', message, ...fields })),
  debug: (message, fields = {}) => console.log(JSON.stringify({ level: 'debug', message, ...fields })),
};

// Database
const sequelize = new Sequelize({
  host: config.db.host,
  dialect: "postgres",
  logging: false,
  username: config.db.user,
  password: config.db.password,
  database: config.db.name,
});

const VideoMetadata = sequelize.define("video_metadata", {
    videoUrl: {
      type: DataTypes.STRING,
      allowNull: false,
      primaryKey: true
    },
    videoId: {
      type: DataTypes.STRING,
      allowNull: false,
      comment: "YouTube/platform-specific video identifier"
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    approximateSize: {
      type: DataTypes.BIGINT,
      allowNull: false,
      comment: "Estimated file size in bytes"
    },
    downloadStatus: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
      comment: "Whether video has been downloaded"
    },
    isAvailable: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: true,
      comment: "Whether video is still available on platform"
    },
    fileName: {
      type: DataTypes.STRING,
      allowNull: true,
      comment: "Name of the file on disk, should have the extension. null if not downloaded."
    },
    thumbNailFile: {
      type: DataTypes.STRING,
      allowNull: true,
      comment: "Thumbnail generated by yt-dlp"
    },
    subTitleFile: {
      type: DataTypes.STRING,
      allowNull: true,
      comment: "Subtitle generated by yt-dlp"
    },
    commentsFile: {
      type: DataTypes.STRING,
      allowNull: true,
      comment: "Comments file generated by yt-dlp"
    },
    descriptionFile: {
      type: DataTypes.STRING,
      allowNull: true,
      comment: "Description retrieved by yt-dlp, not sure yet if I will save the path or read the data and save it here."
    },
    isMetaDataSynced: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
      comment: "This will serve as a marker for other processes to know if they need to sync metadata from downloaded files"
    },
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false
    }
  }, {
    // Explicitly specify the table name
    tableName: 'video_metadata'
});


/**
 * Sanitizes a string to be used as a valid filename.
 * @param {string} input - The string to sanitize.
 * @returns {string} The sanitized string.
 */
function sanitizeFilename(input) {
  return input.replace(/[<>:"/\\|?*]/g, '_');
}

/**
 * Discovers metadata files associated with a downloaded video
 * @param {string} mainFileName - The main video file name
 * @param {string} savePath - Directory where files are saved
 * @returns {object} Object containing paths to discovered metadata files
 */
function discoverFiles(mainFileName, savePath) {
    const files = {
        fileName: null,
        descriptionFile: null,
        commentsFile: null,
        subTitleFile: null,
        thumbNailFile: null
    };

    if (!mainFileName) {
        return files;
    }

    try {
        const mainFileExt = path.extname(mainFileName).toLowerCase();
        const mainFileBase = mainFileName.replace(mainFileExt, '');
        const filesInDir = fs.readdirSync(savePath);

        for (const file of filesInDir) {
            if (file.startsWith(mainFileBase)) {
                const ext = path.extname(file).toLowerCase();
                if (['.mp4', '.webm', '.mkv', '.avi', '.mov', '.flv', '.m4v'].includes(ext)) {
                    files.fileName = file;
                } else if (ext === '.description') {
                    files.descriptionFile = file;
                } else if (ext === '.json' && file.includes('.info')) {
                    files.commentsFile = file;
                } else if (['.vtt', '.srt'].includes(ext)) {
                    files.subTitleFile = file;
                } else if (['.webp', '.jpg', '.jpeg', '.png'].includes(ext)) {
                    files.thumbNailFile = file;
                }
            }
        }
    } catch (error) {
        logger.error('Could not read savePath for extra metadata files', {
            savePath,
            error: error.message
        });
    }

    return files;
}


async function renameFiles() {
  try {
    await sequelize.authenticate();
    logger.info("Connection to database has been established successfully.");

    const videos = await VideoMetadata.findAll({
      where: {
        downloadStatus: true,
      },
    });

    logger.info(`Found ${videos.length} downloaded videos to process.`);

    for (const video of videos) {
      const { title, videoId, fileName } = video;

      if (!fileName) {
        logger.info(`Skipping video with no filename: ${title}`);
        continue;
      }

      const currentFilenameBase = path.basename(fileName, path.extname(fileName));

      // Check if the filename is already in the desired format
      if (currentFilenameBase === `${sanitizeFilename(title)}[${videoId}]`) {
          logger.info(`Skipping already renamed video: ${title}`);
          continue;
      }


      const ext = path.extname(fileName);
      const sanitizedTitle = sanitizeFilename(title);
      const newFileName = `${sanitizedTitle}[${videoId}]${ext}`;

      const playlist = await getPlaylistForVideo(video.videoUrl);
      const saveDirectory = playlist ? playlist.saveDirectory : '';
      const savePath = path.join(config.saveLocation, saveDirectory);


      const associatedFiles = discoverFiles(fileName, savePath);

      const updates = {};

      for (const fileType in associatedFiles) {
        const oldFileName = associatedFiles[fileType];
        if (oldFileName) {
          const oldFilePath = path.join(savePath, oldFileName);
          const newFileTypeFileName = `${sanitizedTitle}[${videoId}]${path.extname(oldFileName)}`;
          const newFilePath = path.join(savePath, newFileTypeFileName);

          try {
            fs.renameSync(oldFilePath, newFilePath);
            logger.info(`Renamed ${oldFilePath} to ${newFilePath}`);
            updates[fileType] = newFileTypeFileName;
          } catch (error) {
            logger.error(`Failed to rename ${oldFilePath} to ${newFilePath}`, { error: error.message });
          }
        }
      }

      if (Object.keys(updates).length > 0) {
        try {
          await video.update(updates);
          logger.info(`Updated database for video: ${title}`);
        } catch (error) {
          logger.error(`Failed to update database for video: ${title}`, { error: error.message });
        }
      }
    }
  } catch (error) {
    logger.error("An error occurred during the file renaming process.", { error: error.message });
  } finally {
    await sequelize.close();
    logger.info("Database connection closed.");
  }
}

async function getPlaylistForVideo(videoUrl) {
    const PlaylistVideoMapping = sequelize.define("playlist_video_mapping", {
        id: {
          type: DataTypes.UUID,
          defaultValue: DataTypes.UUIDV4,
          primaryKey: true,
          allowNull: false
        },
        videoUrl: {
          type: DataTypes.STRING,
          allowNull: false,
          references: {
            model: VideoMetadata,
            key: "videoUrl"
          },
          onUpdate: "CASCADE",
          onDelete: "CASCADE",
          comment: "Foreign key linking to VideoMetadata"
        },
        playlistUrl: {
          type: DataTypes.STRING,
          allowNull: false,
          references: {
            model: 'playlist_metadata',
            key: "playlistUrl"
          },
          onUpdate: "CASCADE",
          onDelete: "CASCADE",
          comment: "Foreign key linking to PlaylistMetadata"
        },
        positionInPlaylist: {
          type: DataTypes.INTEGER,
          allowNull: false,
          defaultValue: 0,
          comment: "Order of video within playlist"
        }
      }, {
          tableName: 'playlist_video_mapping'
      });

      const PlaylistMetadata = sequelize.define("playlist_metadata", {
        playlistUrl: {
          type: DataTypes.STRING,
          allowNull: false,
          primaryKey: true
        },
        title: {
          type: DataTypes.STRING,
          allowNull: false
        },
        sortOrder: {
          type: DataTypes.INTEGER,
          allowNull: false,
          defaultValue: 0,
          comment: "Order in which playlists are displayed"
        },
        monitoringType: {
          type: DataTypes.STRING,
          allowNull: false,
          comment: "Type of monitoring applied to playlist"
        },
        saveDirectory: {
          type: DataTypes.STRING,
          allowNull: false,
          comment: "Directory path for downloaded videos"
        },
        createdAt: {
          type: DataTypes.DATE,
          allowNull: false
        },
        updatedAt: {
          type: DataTypes.DATE,
          allowNull: false
        },
        lastUpdatedByScheduler: {
          type: DataTypes.DATE,
          allowNull: false,
          comment: "Timestamp of the last update made by the scheduler, default value is createdAt"
        },
      }, {
          tableName: 'playlist_metadata'
      });


    const mapping = await PlaylistVideoMapping.findOne({
        where: { videoUrl },
        include: [{ model: PlaylistMetadata, as: 'playlist_metadatum' }]
    });

    return mapping ? mapping.playlist_metadatum : null;
}


renameFiles();
